# API Specification

## Overview

This document defines the comprehensive API specification for the ICARA/MiFIDPRU Platform, designed to support your sophisticated calculator suite including FOR 2.0 (dual approach, 24 subcategories), KFR with SNI intelligence, industry-first SA-CCR K-TCD implementation, and Risk Assessment with velocity factors. The API is built using tRPC for type-safe, modern API development with full TypeScript integration.

**Architecture**: tRPC + Next.js API Routes  
**Authentication**: Auth0/Clerk JWT tokens  
**Data Format**: JSON with Zod validation  
**Real-time**: WebSocket integration for live updates  
**Calculator Focus**: Enterprise-grade regulatory calculation APIs

---

## API Architecture

### 1. Router Structure

```typescript
// API router hierarchy optimized for your calculator platform
export const appRouter = router({
  // Authentication & User Management
  auth: authRouter,
  user: userRouter,
  
  // Core Calculation Routers (Your Main Calculators)
  for: forRouter,           // FOR Calculator 2.0
  kfr: kfrRouter,           // KFR Calculator with SNI intelligence
  kTcd: kTcdRouter,         // Industry-first SA-CCR implementation
  kNpr: kNprRouter,         // K-NPR Calculator
  kCon: kConRouter,         // K-CON Calculator
  kCmg: kCmgRouter,         // K-CMG Calculator
  riskAssessment: riskRouter, // Risk Assessment with velocity factors
  winddown: winddownRouter,  // Winddown Calculator
  
  // Master Calculation
  mcr: mcrRouter,           // MCR aggregation
  
  // Data Management
  firm: firmRouter,
  calculation: calculationRouter,
  
  // Advanced Features
  scenario: scenarioRouter,  // FOR scenario planning
  correlation: correlationRouter, // Risk correlation modeling
  
  // Reporting & Export
  report: reportRouter,
  export: exportRouter,
  
  // Administration
  admin: adminRouter,
  
  // Real-time Updates
  realtime: realtimeRouter
});

export type AppRouter = typeof appRouter;
```

### 2. Base Types and Schemas

#### Core Data Types for Your Calculator Platform
```typescript
import { z } from 'zod';
import { Decimal } from 'decimal.js';

// Enhanced User and Firm Schemas
export const UserSchema = z.object({
  id: z.string().cuid(),
  email: z.string().email(),
  name: z.string().optional(),
  role: z.enum(['ADMIN', 'USER', 'VIEWER', 'AUDITOR']),
  firmId: z.string().cuid(),
  permissions: z.array(z.enum(['CALCULATE', 'EXPORT', 'AUDIT', 'ADMIN'])),
  createdAt: z.date(),
  updatedAt: z.date()
});

export const FirmSchema = z.object({
  id: z.string().cuid(),
  name: z.string().min(1).max(255),
  fcaReference: z.string().regex(/^[0-9]{6}$/, 'FCA reference must be exactly 6 digits'),
  tier: z.enum(['SNI', 'NON_SNI']),
  
  // SNI Classification Data (for your KFR intelligence)
  totalAssets: z.number().nonnegative().optional(),
  balanceSheet: z.number().nonnegative().optional(), 
  annualIncome: z.number().nonnegative().optional(),
  
  // Business Activity Flags
  businessType: z.enum(['advisory', 'discretionary', 'execution', 'custody', 'mixed']).optional(),
  holdsClientMoney: z.boolean().default(false),
  safeguardsAssets: z.boolean().default(false),
  dealsOwnAccount: z.boolean().default(false),
  executesOrders: z.boolean().default(false),
  
  subscriptionId: z.string().cuid().optional(),
  createdAt: z.date(),
  updatedAt: z.date()
});

// FOR Calculator 2.0 Input Schema (Dual Approach)
export const FORInputSchema = z.object({
  firmInfo: z.object({
    firmName: z.string().min(1),
    fcaRef: z.string().regex(/^[0-9]{6}$/),
    financialYear: z.string().regex(/^20[0-9]{2}$/),
    calculationPurpose: z.enum(['annual', 'interim', 'stress-test', 'scenario'])
  }),
  
  // Dual approach system
  approach: z.enum(['consolidated', 'granular']),
  period: z.enum(['quarterly', 'annual']),
  
  // Consolidated approach
  totalExpenditure: z.number().nonnegative().optional(),
  
  // Granular approach (6 categories, 24 subcategories)
  costCategories: z.object({
    staff: z.object({
      name: z.string().default('Staff Costs'),
      value: z.number().nonnegative(),
      icon: z.string().default('ðŸ‘¥'),
      subcategories: z.object({
        salaries: z.object({ name: z.string(), value: z.number().nonnegative() }),
        bonuses: z.object({ name: z.string(), value: z.number().nonnegative() }),
        benefits: z.object({ name: z.string(), value: z.number().nonnegative() }),
        training: z.object({ name: z.string(), value: z.number().nonnegative() })
      })
    }),
    professional: z.object({
      name: z.string().default('Professional Fees'),
      value: z.number().nonnegative(),
      icon: z.string().default('âš–ï¸'),
      subcategories: z.object({
        legal: z.object({ name: z.string(), value: z.number().nonnegative() }),
        audit: z.object({ name: z.string(), value: z.number().nonnegative() }),
        consultancy: z.object({ name: z.string(), value: z.number().nonnegative() }),
        tax: z.object({ name: z.string(), value: z.number().nonnegative() })
      })
    }),
    technology: z.object({
      name: z.string().default('Technology/IT Costs'),
      value: z.number().nonnegative(), 
      icon: z.string().default('ðŸ’»'),
      subcategories: z.object({
        software: z.object({ name: z.string(), value: z.number().nonnegative() }),
        hardware: z.object({ name: z.string(), value: z.number().nonnegative() }),
        maintenance: z.object({ name: z.string(), value: z.number().nonnegative() }),
        telecoms: z.object({ name: z.string(), value: z.number().nonnegative() })
      })
    }),
    occupancy: z.object({
      name: z.string().default('Occupancy & Facilities'),
      value: z.number().nonnegative(),
      icon: z.string().default('ðŸ¢'),
      subcategories: z.object({
        rent: z.object({ name: z.string(), value: z.number().nonnegative() }),
        utilities: z.object({ name: z.string(), value: z.number().nonnegative() }),
        insurance: z.object({ name: z.string(), value: z.number().nonnegative() }),
        maintenance: z.object({ name: z.string(), value: z.number().nonnegative() })
      })
    }),
    regulatory: z.object({
      name: z.string().default('Regulatory & Compliance'),
      value: z.number().nonnegative(),
      icon: z.string().default('ðŸ“‹'),
      subcategories: z.object({
        fcaFees: z.object({ name: z.string(), value: z.number().nonnegative() }),
        compliance: z.object({ name: z.string(), value: z.number().nonnegative() }),
        reporting: z.object({ name: z.string(), value: z.number().nonnegative() }),
        licensing: z.object({ name: z.string(), value: z.number().nonnegative() })
      })
    }),
    other: z.object({
      name: z.string().default('Other Operating Costs'),
      value: z.number().nonnegative(),
      icon: z.string().default('ðŸ“Š'),
      subcategories: z.object({
        marketing: z.object({ name: z.string(), value: z.number().nonnegative() }),
        travel: z.object({ name: z.string(), value: z.number().nonnegative() }),
        office: z.object({ name: z.string(), value: z.number().nonnegative() }),
        miscellaneous: z.object({ name: z.string(), value: z.number().nonnegative() })
      })
    })
  }).optional(),
  
  // FOR Adjustments (MiFIDPRU 4.5.3R)
  adjustments: z.array(z.object({
    id: z.number(),
    description: z.string().min(1),
    amount: z.number(), // Can be negative
    date: z.string().datetime()
  })).optional()
});

// KFR Input Schema (with SNI Intelligence)
export const KFRInputSchema = z.object({
  firmInfo: z.object({
    firmName: z.string(),
    fcaRef: z.string().regex(/^[0-9]{6}$/),
    
    // SNI Classification Data
    totalAssets: z.number().nonnegative(),
    balanceSheet: z.number().nonnegative(),
    annualIncome: z.number().nonnegative(),
    
    // Business activity flags for K-factor applicability
    businessType: z.enum(['advisory', 'discretionary', 'execution', 'custody', 'mixed']),
    holdsClientMoney: z.boolean(),
    safeguardsAssets: z.boolean(),
    dealsOwnAccount: z.boolean(),
    executesOrders: z.boolean()
  }),
  
  // All 9 K-factors across 3 risk categories
  kFactorData: z.object({
    // Risk to Client (RtC)
    rtc: z.object({
      k_aum: z.object({
        active: z.boolean(),
        value: z.number().nonnegative().optional()
      }).optional(),
      k_cmh: z.object({
        active: z.boolean(),
        componentValues: z.object({
          segregated: z.number().nonnegative(),
          nonSegregated: z.number().nonnegative()
        }).optional()
      }).optional(),
      k_asa: z.object({
        active: z.boolean(),
        value: z.number().nonnegative().optional()
      }).optional(),
      k_coh: z.object({
        active: z.boolean(),
        componentValues: z.object({
          cash: z.number().nonnegative(),
          derivatives: z.number().nonnegative()
        }).optional()
      }).optional()
    }).optional(),
    
    // Risk to Market (RtM)
    rtm: z.object({
      k_npr: z.object({
        active: z.boolean(),
        calculatedValue: z.number().nonnegative().optional() // From K-NPR calculator
      }).optional(),
      k_cmg: z.object({
        active: z.boolean(),
        calculatedValue: z.number().nonnegative().optional() // From K-CMG calculator
      }).optional()
    }).optional(),
    
    // Risk to Firm (RtF)
    rtf: z.object({
      k_tcd: z.object({
        active: z.boolean(),
        calculatedValue: z.number().nonnegative().optional() // From SA-CCR calculator
      }).optional(),
      k_dtf: z.object({
        active: z.boolean(),
        componentValues: z.object({
          cash: z.number().nonnegative(),
          derivatives: z.number().nonnegative()
        }).optional()
      }).optional(),
      k_con: z.object({
        active: z.boolean(),
        calculatedValue: z.number().nonnegative().optional() // From K-CON calculator
      }).optional()
    }).optional()
  })
});

// K-TCD SA-CCR Input Schema (Industry First Implementation)
export const KTCDInputSchema = z.object({
  nettingSets: z.array(z.object({
    id: z.string(),
    counterparty: z.string(),
    counterpartyType: z.enum(['financial', 'corporate', 'sovereign', 'other']),
    riskWeight: z.number().min(0).max(1.5), // CRR risk weights
    
    // Margin agreement details
    marginType: z.enum(['none', 'vm', 'vmim']), // None, VM only, VM+IM
    collateralHeld: z.number().nonnegative(),
    collateralPosted: z.number().nonnegative(),
    threshold: z.number().nonnegative(),
    minimumTransferAmount: z.number().nonnegative().optional(),
    
    // Transaction portfolio
    transactions: z.array(z.object({
      id: z.string(),
      assetClass: z.enum(['ir', 'fx', 'credit', 'equity', 'commodity']),
      productType: z.enum(['swap', 'option', 'forward', 'future', 'cds', 'other']),
      notional: z.number().positive(),
      marketValue: z.number(), // Can be negative
      maturity: z.number().positive(), // Years
      position: z.enum(['long', 'short']),
      
      // Asset class specific fields
      underlyingCurrency: z.string().length(3).optional(), // For FX
      creditRating: z.enum(['IG', 'SG', 'HY', 'unrated']).optional(), // For credit
      equityType: z.enum(['single', 'index']).optional(), // For equity
      commodityType: z.enum(['energy', 'metals', 'agriculture', 'other']).optional()
    }))
  }))
});

// Risk Assessment Input Schema (with Velocity Factors)
export const RiskAssessmentInputSchema = z.object({
  risks: z.array(z.object({
    id: z.string(),
    category: z.enum(['operational', 'liquidity', 'concentration', 'group', 'esg', 'other']),
    name: z.string().min(1),
    description: z.string().min(1),
    
    // Standard risk assessment
    impact: z.number().int().min(1).max(10),
    likelihood: z.number().int().min(1).max(10),
    controlEffectiveness: z.number().int().min(1).max(10),
    
    // Your industry-first velocity factor
    velocityFactor: z.object({
      crystallizationSpeed: z.enum(['immediate', 'fast', 'medium', 'slow']),
      detectionLag: z.enum(['none', 'short', 'medium', 'long']),
      responseTime: z.enum(['immediate', 'fast', 'medium', 'slow']),
      recoveryDuration: z.enum(['immediate', 'short', 'medium', 'long'])
    }),
    
    // Controls documentation
    controls: z.array(z.object({
      id: z.string(),
      type: z.enum(['preventive', 'detective', 'corrective']),
      description: z.string(),
      effectiveness: z.number().min(0).max(10),
      evidence: z.string().optional()
    })),
    
    // Capital allocation
    allocatedCapital: z.number().nonnegative().optional()
  })),
  
  // Correlation matrix for portfolio effects
  correlationMatrix: z.record(z.string(), z.number().min(-1).max(1)).optional()
});
```

---

## FOR Calculator 2.0 Router

### 1. Dual Approach Calculation Endpoints

```typescript
export const forRouter = router({
  // Main calculation endpoint supporting both approaches
  calculate: procedure
    .input(FORInputSchema)
    .output(z.object({
      forRequirement: z.number().nonnegative(),
      annualExpenditure: z.number().nonnegative(),
      adjustedExpenditure: z.number().nonnegative(),
      adjustmentTotal: z.number(),
      monthlyRunRate: z.number().nonnegative(),
      dailyBurnRate: z.number().nonnegative(),
      coverageDays: z.number().nonnegative(),
      
      // Approach-specific breakdowns
      breakdown: z.object({
        staff: z.number().nonnegative(),
        professional: z.number().nonnegative(),
        technology: z.number().nonnegative(),
        occupancy: z.number().nonnegative(),
        regulatory: z.number().nonnegative(),
        other: z.number().nonnegative()
      }).optional(),
      
      // Granular subcategory breakdown (if granular approach)
      subcategoryBreakdown: z.record(z.string(), z.record(z.string(), z.number())).optional(),
      
      metadata: z.object({
        calculationDate: z.date(),
        approach: z.enum(['consolidated', 'granular']),
        version: z.string(),
        methodology: z.string(),
        regulatoryBasis: z.string(),
        adjustmentsApplied: z.boolean()
      })
    }))
    .mutation(async ({ input, ctx }) => {
      // Validate user permissions
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      // Perform calculation using your proven logic
      const result = FORCalculator.calculate(input);
      
      // Create audit trail with detailed breakdown
      const calculation = await ctx.db.calculation.create({
        data: {
          firmId: ctx.user.firmId,
          userId: ctx.user.id,
          type: 'FOR',
          version: '2.0',
          input: input as any,
          result: result as any,
          metadata: {
            ipAddress: ctx.req.ip,
            userAgent: ctx.req.headers['user-agent'],
            timestamp: new Date().toISOString(),
            approach: input.approach,
            categoryCount: input.approach === 'granular' ? 6 : 1,
            subcategoryCount: input.approach === 'granular' ? 24 : 0
          }
        }
      });
      
      // Emit real-time update
      ctx.websocket?.emit(`firm:${ctx.user.firmId}:for:updated`, {
        type: 'FOR',
        result,
        calculationId: calculation.id,
        approach: input.approach
      });
      
      return result;
    }),

  // Switch calculation approach
  switchApproach: procedure
    .input(z.object({
      currentData: FORInputSchema,
      targetApproach: z.enum(['consolidated', 'granular'])
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      // Transform data between approaches
      const transformedData = FORCalculator.transformApproach(
        input.currentData, 
        input.targetApproach
      );
      
      return {
        transformedData,
        preservedFields: FORCalculator.getPreservedFields(input.currentData),
        conversionNote: input.targetApproach === 'granular' 
          ? 'Data distributed across categories using default allocation'
          : 'Category data aggregated into total expenditure'
      };
    }),

  // Scenario planning endpoints
  calculateScenario: procedure
    .input(z.object({
      baseInput: FORInputSchema,
      scenario: z.object({
        type: z.enum(['growth', 'efficiency', 'custom']),
        name: z.string(),
        adjustments: z.object({
          staffIncrease: z.number().min(-1).max(10).optional(), // -100% to +1000%
          infrastructureScaling: z.number().min(-1).max(10).optional(),
          efficiencyGains: z.number().min(-1).max(10).optional(),
          customAdjustments: z.record(z.string(), z.number()).optional()
        })
      })
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      // Calculate base FOR
      const baseResult = FORCalculator.calculate(input.baseInput);
      
      // Apply scenario adjustments
      const scenarioResult = FORScenarioCalculator.calculate(
        input.baseInput,
        input.scenario
      );
      
      // Calculate scenario impact
      const impact = FORScenarioCalculator.calculateImpact(baseResult, scenarioResult);
      
      return {
        baseResult,
        scenarioResult,
        impact: {
          absoluteChange: impact.absoluteChange,
          percentageChange: impact.percentageChange,
          categoryImpacts: impact.categoryImpacts,
          sensitivityAnalysis: impact.sensitivityAnalysis
        },
        metadata: {
          scenarioName: input.scenario.name,
          scenarioType: input.scenario.type,
          calculationDate: new Date()
        }
      };
    }),

  // Historical tracking
  getHistoricalTrend: procedure
    .input(z.object({
      months: z.number().int().min(1).max(24).default(12),
      includeScenarios: z.boolean().default(false)
    }))
    .query(async ({ input, ctx }) => {
      const calculations = await ctx.db.calculation.findMany({
        where: {
          firmId: ctx.user.firmId,
          type: 'FOR',
          createdAt: {
            gte: new Date(Date.now() - input.months * 30 * 24 * 60 * 60 * 1000)
          }
        },
        orderBy: {
          createdAt: 'asc'
        },
        select: {
          id: true,
          result: true,
          createdAt: true,
          metadata: true
        }
      });
      
      // Process trend data
      const trendData = calculations.map(calc => ({
        date: calc.createdAt,
        forValue: (calc.result as any).forRequirement,
        totalCosts: (calc.result as any).annualExpenditure,
        approach: (calc.metadata as any).approach,
        categoryBreakdown: (calc.result as any).breakdown
      }));
      
      return {
        trend: trendData,
        analytics: {
          averageFOR: trendData.reduce((sum, d) => sum + d.forValue, 0) / trendData.length,
          highestFOR: Math.max(...trendData.map(d => d.forValue)),
          lowestFOR: Math.min(...trendData.map(d => d.forValue)),
          volatility: FORAnalytics.calculateVolatility(trendData),
          trendDirection: FORAnalytics.calculateTrend(trendData)
        }
      };
    }),

  // Save/load calculation drafts
  saveDraft: procedure
    .input(z.object({
      draftId: z.string().cuid().optional(),
      data: FORInputSchema.partial(),
      name: z.string().optional()
    }))
    .mutation(async ({ input, ctx }) => {
      const draftData = await ctx.db.calculationDraft.upsert({
        where: {
          id: input.draftId || 'new'
        },
        create: {
          firmId: ctx.user.firmId,
          userId: ctx.user.id,
          type: 'FOR',
          name: input.name || `FOR Draft ${new Date().toLocaleDateString()}`,
          data: input.data as any
        },
        update: {
          data: input.data as any,
          name: input.name,
          updatedAt: new Date()
        }
      });
      
      return { draftId: draftData.id, name: draftData.name };
    })
});
```

---

## KFR Calculator Router (SNI Intelligence)

### 1. SNI Classification and K-Factor Management

```typescript
export const kfrRouter = router({
  // Main KFR calculation with SNI intelligence
  calculate: procedure
    .input(KFRInputSchema)
    .output(z.object({
      kfrRequirement: z.number().nonnegative(),
      
      // SNI Classification Intelligence
      sniClassification: z.object({
        isSNI: z.boolean(),
        thresholdAnalysis: z.object({
          totalAssets: z.object({ value: z.number(), threshold: z.number(), belowThreshold: z.boolean() }),
          balanceSheet: z.object({ value: z.number(), threshold: z.number(), belowThreshold: z.boolean() }),
          annualIncome: z.object({ value: z.number(), threshold: z.number(), belowThreshold: z.boolean() })
        }),
        reason: z.string(),
        implication: z.string()
      }),
      
      // Calculated K-factors (shown even for SNI firms for transparency)
      calculatedKFactors: z.object({
        rtc: z.object({
          k_aum: z.number().optional(),
          k_cmh: z.number().optional(),
          k_asa: z.number().optional(),
          k_coh: z.number().optional(),
          total: z.number()
        }),
        rtm: z.object({
          k_npr: z.number().optional(),
          k_cmg: z.number().optional(),
          total: z.number()
        }),
        rtf: z.object({
          k_tcd: z.number().optional(),
          k_dtf: z.number().optional(),
          k_con: z.number().optional(),
          total: z.number()
        }),
        grandTotal: z.number()
      }),
      
      // Component breakdowns
      componentBreakdowns: z.record(z.string(), z.any()),
      
      metadata: z.object({
        calculationDate: z.date(),
        version: z.string(),
        methodology: z.string(),
        activeKFactors: z.array(z.string()),
        coefficientsApplied: z.record(z.string(), z.number())
      })
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      // Perform SNI classification first
      const sniClassification = KFRCalculator.classifyFirm(input.firmInfo);
      
      // Calculate all K-factors (for transparency, even if SNI)
      const calculatedKFactors = KFRCalculator.calculateAllKFactors(input.kFactorData);
      
      // Determine final KFR requirement
      const kfrRequirement = sniClassification.isSNI ? 0 : calculatedKFactors.grandTotal;
      
      const result = {
        kfrRequirement,
        sniClassification,
        calculatedKFactors,
        componentBreakdowns: KFRCalculator.getComponentBreakdowns(input.kFactorData),
        metadata: {
          calculationDate: new Date(),
          version: '2.0',
          methodology: 'MiFIDPRU 4.6',
          activeKFactors: KFRCalculator.getActiveKFactors(input.kFactorData),
          coefficientsApplied: KFRCalculator.getCoefficients()
        }
      };
      
      // Save calculation
      await ctx.db.calculation.create({
        data: {
          firmId: ctx.user.firmId,
          userId: ctx.user.id,
          type: 'KFR',
          version: '2.0',
          input: input as any,
          result: result as any,
          metadata: {
            sniClassification: sniClassification.isSNI,
            activeKFactorCount: result.metadata.activeKFactors.length,
            timestamp: new Date().toISOString()
          }
        }
      });
      
      return result;
    }),

  // Real-time SNI threshold monitoring
  checkSNIStatus: procedure
    .input(z.object({
      totalAssets: z.number().nonnegative(),
      balanceSheet: z.number().nonnegative(),
      annualIncome: z.number().nonnegative()
    }))
    .query(async ({ input }) => {
      const sniThresholds = {
        totalAssets: 5000000,    // Â£5M
        balanceSheet: 5000000,   // Â£5M
        annualIncome: 5000000    // Â£5M
      };
      
      const classification = KFRCalculator.classifyFirm(input);
      
      return {
        isSNI: classification.isSNI,
        thresholdAnalysis: classification.thresholdAnalysis,
        proximityToThresholds: {
          totalAssets: {
            distanceToThreshold: sniThresholds.totalAssets - input.totalAssets,
            percentageOfThreshold: (input.totalAssets / sniThresholds.totalAssets) * 100
          },
          balanceSheet: {
            distanceToThreshold: sniThresholds.balanceSheet - input.balanceSheet,
            percentageOfThreshold: (input.balanceSheet / sniThresholds.balanceSheet) * 100
          },
          annualIncome: {
            distanceToThreshold: sniThresholds.annualIncome - input.annualIncome,
            percentageOfThreshold: (input.annualIncome / sniThresholds.annualIncome) * 100
          }
        }
      };
    }),

  // Component calculation endpoints
  calculateKCMH: procedure
    .input(z.object({
      segregated: z.number().nonnegative(),
      nonSegregated: z.number().nonnegative()
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      const coefficient = 0.0032; // 0.32%
      
      const result = {
        segregatedComponent: input.segregated * coefficient,
        nonSegregatedComponent: input.nonSegregated * coefficient,
        totalKCMH: (input.segregated + input.nonSegregated) * coefficient,
        coefficients: {
          segregated: coefficient,
          nonSegregated: coefficient
        },
        breakdown: {
          segregated: {
            input: input.segregated,
            coefficient: coefficient,
            output: input.segregated * coefficient
          },
          nonSegregated: {
            input: input.nonSegregated,
            coefficient: coefficient,
            output: input.nonSegregated * coefficient
          }
        }
      };
      
      return result;
    }),

  // Integration with supplementary calculators
  integrateSupplementaryCalculations: procedure
    .input(z.object({
      kNprResult: z.number().nonnegative().optional(),
      kTcdResult: z.number().nonnegative().optional(),
      kConResult: z.number().nonnegative().optional(),
      kCmgResult: z.number().nonnegative().optional()
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      // Get latest KFR calculation
      const latestKFR = await ctx.db.calculation.findFirst({
        where: {
          firmId: ctx.user.firmId,
          type: 'KFR'
        },
        orderBy: { createdAt: 'desc' }
      });
      
      if (!latestKFR) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'No KFR calculation found to integrate with'
        });
      }
      
      // Update with supplementary calculator results
      const updatedResult = KFRCalculator.integrateSupplementaryResults(
        latestKFR.result as any,
        input
      );
      
      return {
        updatedKFR: updatedResult,
        integrationSummary: {
          kNprIntegrated: !!input.kNprResult,
          kTcdIntegrated: !!input.kTcdResult,
          kConIntegrated: !!input.kConResult,
          kCmgIntegrated: !!input.kCmgResult
        }
      };
    })
});
```

---

## K-TCD SA-CCR Router (Industry First Implementation)

### 1. Complete SA-CCR Calculation Chain

```typescript
export const kTcdRouter = router({
  // Main SA-CCR calculation endpoint
  calculate: procedure
    .input(KTCDInputSchema)
    .output(z.object({
      totalKTCD: z.number().nonnegative(),
      totalRWA: z.number().nonnegative(),
      cvaCharge: z.number().nonnegative(),
      
      // Netting set results
      nettingSetResults: z.array(z.object({
        nettingSetId: z.string(),
        counterparty: z.string(),
        replacementCost: z.number().nonnegative(),
        potentialFutureExposure: z.number().nonnegative(),
        exposureAtDefault: z.number().nonnegative(),
        riskWeightedAssets: z.number().nonnegative(),
        
        // SA-CCR calculation breakdown
        calculationBreakdown: z.object({
          netMarketValue: z.number(),
          netCollateral: z.number(),
          alphaFactor: z.number(),
          assetClassBreakdown: z.record(z.string(), z.object({
            effectiveNotional: z.number(),
            supervisoryFactor: z.number(),
            maturityFactor: z.number(),
            pfe: z.number()
          }))
        })
      })),
      
      metadata: z.object({
        calculationDate: z.date(),
        methodology: z.string(),
        implementationType: z.string(),
        industryFirst: z.boolean(),
        regulatoryBasis: z.string(),
        version: z.string()
      })
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      // Perform SA-CCR calculation using your industry-first implementation
      const result = KTCDCalculator.calculate(input);
      
      // Create detailed audit trail for regulatory review
      const calculation = await ctx.db.calculation.create({
        data: {
          firmId: ctx.user.firmId,
          userId: ctx.user.id,
          type: 'K_TCD',
          version: '1.0',
          input: input as any,
          result: result as any,
          metadata: {
            methodology: 'SA-CCR',
            nettingSetCount: input.nettingSets.length,
            totalTransactions: input.nettingSets.reduce(
              (sum, ns) => sum + ns.transactions.length, 
              0
            ),
            assetClasses: getUniqueAssetClasses(input),
            industryFirst: true,
            timestamp: new Date().toISOString()
          }
        }
      });
      
      // Emit real-time update
      ctx.websocket?.emit(`firm:${ctx.user.firmId}:ktcd:updated`, {
        type: 'K_TCD',
        result,
        calculationId: calculation.id
      });
      
      return result;
    }),

  // Calculate Replacement Cost only
  calculateRC: procedure
    .input(z.object({
      nettingSetId: z.string(),
      transactions: z.array(z.object({
        marketValue: z.number()
      })),
      marginDetails: z.object({
        type: z.enum(['none', 'vm', 'vmim']),
        collateralHeld: z.number().nonnegative(),
        collateralPosted: z.number().nonnegative(),
        threshold: z.number().nonnegative()
      })
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      const result = KTCDCalculator.calculateReplacementCost({
        transactions: input.transactions,
        marginType: input.marginDetails.type,
        collateralHeld: input.marginDetails.collateralHeld,
        collateralPosted: input.marginDetails.collateralPosted,
        threshold: input.marginDetails.threshold
      });
      
      return {
        nettingSetId: input.nettingSetId,
        replacementCost: result.replacementCost,
        netMarketValue: result.netMarketValue,
        netCollateral: result.netCollateral,
        calculationFormula: result.formula,
        marginType: input.marginDetails.type
      };
    }),

  // Calculate Potential Future Exposure only
  calculatePFE: procedure
    .input(z.object({
      nettingSetId: z.string(),
      transactions: z.array(z.object({
        assetClass: z.enum(['ir', 'fx', 'credit', 'equity', 'commodity']),
        notional: z.number().positive(),
        maturity: z.number().positive()
      }))
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      const result = KTCDCalculator.calculatePFE(input.transactions);
      
      return {
        nettingSetId: input.nettingSetId,
        totalPFE: result.totalPFE,
        assetClassBreakdown: result.assetClassBreakdown,
        correlationEffects: result.correlationEffects,
        supervisoryFactors: result.supervisoryFactors
      };
    }),

  // Advanced portfolio analysis
  analyzePortfolio: procedure
    .input(KTCDInputSchema)
    .query(async ({ input, ctx }) => {
      const analysis = KTCDAnalyzer.analyzePortfolio(input);
      
      return {
        portfolioSummary: {
          totalNotional: analysis.totalNotional,
          transactionCount: analysis.transactionCount,
          nettingSetCount: analysis.nettingSetCount,
          assetClassDistribution: analysis.assetClassDistribution,
          maturityProfile: analysis.maturityProfile
        },
        riskAnalysis: {
          concentrationRisks: analysis.concentrationRisks,
          marginEfficiency: analysis.marginEfficiency,
          diversificationBenefits: analysis.diversificationBenefits
        },
        recommendations: analysis.recommendations
      };
    }),

  // Export SA-CCR calculation details
  exportCalculationDetails: procedure
    .input(z.object({
      calculationId: z.string().cuid(),
      format: z.enum(['json', 'excel', 'regulatory_template'])
    }))
    .mutation(async ({ input, ctx }) => {
      const calculation = await ctx.db.calculation.findUnique({
        where: {
          id: input.calculationId,
          firmId: ctx.user.firmId,
          type: 'K_TCD'
        }
      });
      
      if (!calculation) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'K-TCD calculation not found'
        });
      }
      
      const exportData = KTCDExporter.export(
        calculation,
        input.format
      );
      
      return {
        exportUrl: exportData.url,
        filename: exportData.filename,
        format: input.format,
        expiresAt: new Date(Date.now() + 3600000) // 1 hour
      };
    })
});
```

---

## Risk Assessment Router (Velocity Factors)

### 1. Advanced Risk Modeling with Velocity

```typescript
export const riskRouter = router({
  // Main risk assessment calculation with velocity factors
  calculate: procedure
    .input(RiskAssessmentInputSchema)
    .output(z.object({
      totalCapitalAllocation: z.number().nonnegative(),
      portfolioCapital: z.number().nonnegative(),
      diversificationBenefit: z.number().nonnegative(),
      
      // Individual risk results
      riskResults: z.array(z.object({
        riskId: z.string(),
        grossRisk: z.number(),
        netRisk: z.number(),
        velocityAdjustedRisk: z.number(),
        allocatedCapital: z.number(),
        
        // Velocity factor breakdown
        velocityAnalysis: z.object({
          velocityMultiplier: z.number(),
          crystallizationImpact: z.number(),
          detectionImpact: z.number(),
          responseImpact: z.number(),
          recoveryImpact: z.number()
        }),
        
        // Controls assessment
        controlsEffectiveness: z.object({
          grossToNetReduction: z.number(),
          controlGaps: z.array(z.string()),
          recommendedImprovements: z.array(z.string())
        })
      })),
      
      // Correlation analysis
      correlationAnalysis: z.object({
        correlationMatrix: z.record(z.string(), z.number()),
        highestCorrelation: z.number(),
        portfolioEffect: z.number(),
        diversificationScore: z.number()
      }),
      
      metadata: z.object({
        calculationDate: z.date(),
        version: z.string(),
        methodology: z.string(),
        velocityModelVersion: z.string(),
        industryFirst: z.boolean()
      })
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      // Calculate individual risks with velocity factors
      const riskResults = await Promise.all(
        input.risks.map(risk => RiskCalculator.calculateWithVelocity(risk))
      );
      
      // Calculate portfolio effects with correlations
      const portfolioResult = RiskCalculator.calculatePortfolioCapital(
        riskResults,
        input.correlationMatrix
      );
      
      const result = {
        totalCapitalAllocation: portfolioResult.totalCapital,
        portfolioCapital: portfolioResult.portfolioCapital,
        diversificationBenefit: portfolioResult.diversificationBenefit,
        riskResults,
        correlationAnalysis: portfolioResult.correlationAnalysis,
        metadata: {
          calculationDate: new Date(),
          version: '1.0',
          methodology: 'MiFIDPRU 7.7 + Velocity Factors',
          velocityModelVersion: '1.0',
          industryFirst: true
        }
      };
      
      // Save calculation
      await ctx.db.calculation.create({
        data: {
          firmId: ctx.user.firmId,
          userId: ctx.user.id,
          type: 'RISK_ASSESSMENT',
          version: '1.0',
          input: input as any,
          result: result as any,
          metadata: {
            riskCount: input.risks.length,
            velocityFactorsUsed: true,
            correlationModelingUsed: !!input.correlationMatrix,
            timestamp: new Date().toISOString()
          }
        }
      });
      
      return result;
    }),

  // Velocity factor calibration
  calibrateVelocityFactors: procedure
    .input(z.object({
      riskCategory: z.enum(['operational', 'liquidity', 'concentration', 'group', 'esg']),
      historicalIncidents: z.array(z.object({
        incidentType: z.string(),
        crystallizationTime: z.number(), // Hours
        detectionTime: z.number(), // Hours
        responseTime: z.number(), // Hours
        recoveryTime: z.number() // Days
      })),
      industryBenchmarks: z.object({
        averageCrystallization: z.number(),
        averageDetection: z.number(),
        averageResponse: z.number(),
        averageRecovery: z.number()
      }).optional()
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      const calibration = VelocityFactorCalibrator.calibrate(
        input.riskCategory,
        input.historicalIncidents,
        input.industryBenchmarks
      );
      
      return {
        calibratedFactors: calibration.factors,
        confidence: calibration.confidence,
        recommendations: calibration.recommendations,
        benchmarkComparison: calibration.benchmarkComparison
      };
    }),

  // Dynamic correlation modeling
  calculateCorrelations: procedure
    .input(z.object({
      risks: z.array(z.object({
        id: z.string(),
        category: z.string(),
        netRisk: z.number()
      })),
      correlationMethod: z.enum(['historical', 'expert_judgment', 'hybrid'])
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      const correlationMatrix = CorrelationModeler.calculate(
        input.risks,
        input.correlationMethod
      );
      
      return {
        correlationMatrix,
        method: input.correlationMethod,
        confidence: correlationMatrix.confidence,
        keyInsights: correlationMatrix.insights
      };
    }),

  // Risk heat map generation
  generateHeatMap: procedure
    .input(z.object({
      riskResults: z.array(z.object({
        riskId: z.string(),
        impact: z.number(),
        likelihood: z.number(),
        velocityAdjustedRisk: z.number()
      }))
    }))
    .query(async ({ input }) => {
      const heatMap = RiskHeatMapGenerator.generate(input.riskResults);
      
      return {
        heatMapData: heatMap.data,
        riskPositions: heatMap.positions,
        riskLevels: heatMap.levels,
        visualConfig: heatMap.config
      };
    })
});
```

---

## Real-time Updates and Integration

### 1. WebSocket Integration for Live Calculations

```typescript
export const realtimeRouter = router({
  // Subscribe to all calculator updates
  subscribeToCalculations: procedure
    .input(z.object({
      calculators: z.array(z.enum(['FOR', 'KFR', 'K_TCD', 'K_NPR', 'K_CON', 'RISK_ASSESSMENT'])).optional()
    }))
    .subscription(async ({ input, ctx }) => {
      const observable = new Observable<CalculationUpdate>((subscriber) => {
        const calculatorTypes = input.calculators || ['FOR', 'KFR', 'K_TCD', 'K_NPR', 'K_CON', 'RISK_ASSESSMENT'];
        
        calculatorTypes.forEach(type => {
          ctx.websocket?.on(`firm:${ctx.user.firmId}:${type.toLowerCase()}:updated`, (data) => {
            subscriber.next({
              type,
              data,
              timestamp: new Date(),
              userId: ctx.user.id,
              calculationId: data.calculationId
            });
          });
        });
        
        return () => {
          calculatorTypes.forEach(type => {
            ctx.websocket?.off(`firm:${ctx.user.firmId}:${type.toLowerCase()}:updated`);
          });
        };
      });
      
      return observable;
    }),

  // Subscribe to MCR updates (aggregated from all calculators)
  subscribeToMCR: procedure
    .subscription(async ({ ctx }) => {
      const observable = new Observable<MCRUpdate>((subscriber) => {
        ctx.websocket?.on(`firm:${ctx.user.firmId}:mcr:updated`, (data) => {
          subscriber.next({
            mcr: data.mcr,
            components: {
              for: data.components.for,
              kfr: data.components.kfr,
              winddown: data.components.winddown,
              riskAssessment: data.components.riskAssessment
            },
            drivingComponent: data.drivingComponent,
            timestamp: new Date()
          });
        });
        
        return () => {
          ctx.websocket?.off(`firm:${ctx.user.firmId}:mcr:updated`);
        };
      });
      
      return observable;
    })
});
```

---

## Master MCR Calculator Router

### 1. Aggregated MCR Calculation

```typescript
export const mcrRouter = router({
  // Calculate complete MCR from all components
  calculateMCR: procedure
    .input(z.object({
      useLatestCalculations: z.boolean().default(true),
      forInput: FORInputSchema.optional(),
      kfrInput: KFRInputSchema.optional(),
      winddownInput: z.any().optional(),
      riskInput: RiskAssessmentInputSchema.optional()
    }))
    .output(z.object({
      mcr: z.number().nonnegative(),
      ofr: z.number().nonnegative(),
      wda: z.number().nonnegative(),
      ra: z.number().nonnegative(),
      drivingComponent: z.enum(['OFR', 'WDA', 'RA']),
      
      components: z.object({
        for: z.number().nonnegative(),
        kfr: z.number().nonnegative(),
        winddown: z.number().nonnegative(),
        riskAssessment: z.number().nonnegative()
      }),
      
      breakdown: z.object({
        forBreakdown: z.any(),
        kfrBreakdown: z.any(),
        winddownBreakdown: z.any(),
        riskBreakdown: z.any()
      }),
      
      metadata: z.object({
        calculationDate: z.date(),
        version: z.string(),
        methodology: z.string(),
        componentVersions: z.record(z.string(), z.string())
      })
    }))
    .mutation(async ({ input, ctx }) => {
      await requireCalculatorAccess(ctx.user, ctx.firm);
      
      let components: any = {};
      
      if (input.useLatestCalculations) {
        // Get latest calculations from database
        components = await getLatestCalculationComponents(ctx.user.firmId);
      } else {
        // Calculate from provided inputs
        if (input.forInput) {
          components.for = FORCalculator.calculate(input.forInput);
        }
        if (input.kfrInput) {
          components.kfr = KFRCalculator.calculate(input.kfrInput);
        }
        // ... other components
      }
      
      // Calculate MCR using regulatory formula: MCR = max(OFR, WDA, RA)
      const ofr = Math.max(
        components.for?.forRequirement || 0,
        components.kfr?.kfrRequirement || 0
      );
      
      const wda = components.winddown?.totalCosts || 0;
      const ra = components.riskAssessment?.totalCapitalAllocation || 0;
      
      const mcr = Math.max(ofr, wda, ra);
      
      // Determine driving component
      let drivingComponent: 'OFR' | 'WDA' | 'RA';
      if (mcr === ofr) {
        drivingComponent = 'OFR';
      } else if (mcr === wda) {
        drivingComponent = 'WDA';
      } else {
        drivingComponent = 'RA';
      }
      
      const result = {
        mcr,
        ofr,
        wda,
        ra,
        drivingComponent,
        components: {
          for: components.for?.forRequirement || 0,
          kfr: components.kfr?.kfrRequirement || 0,
          winddown: wda,
          riskAssessment: ra
        },
        breakdown: {
          forBreakdown: components.for?.breakdown || {},
          kfrBreakdown: components.kfr?.calculatedKFactors || {},
          winddownBreakdown: components.winddown?.breakdown || {},
          riskBreakdown: components.riskAssessment?.riskResults || {}
        },
        metadata: {
          calculationDate: new Date(),
          version: '1.0',
          methodology: 'MiFIDPRU 4.3',
          componentVersions: {
            for: components.for?.metadata?.version || 'N/A',
            kfr: components.kfr?.metadata?.version || 'N/A',
            winddown: components.winddown?.metadata?.version || 'N/A',
            riskAssessment: components.riskAssessment?.metadata?.version || 'N/A'
          }
        }
      };
      
      // Save master MCR calculation
      await ctx.db.calculation.create({
        data: {
          firmId: ctx.user.firmId,
          userId: ctx.user.id,
          type: 'MCR',
          version: '1.0',
          input: input as any,
          result: result as any,
          metadata: {
            drivingComponent,
            componentCount: Object.keys(components).length,
            timestamp: new Date().toISOString()
          }
        }
      });
      
      // Emit real-time MCR update
      ctx.websocket?.emit(`firm:${ctx.user.firmId}:mcr:updated`, result);
      
      return result;
    })
});
```

This comprehensive API specification provides enterprise-grade endpoints for your sophisticated calculator platform, supporting all the advanced features you've built including dual-approach FOR calculations, SNI intelligence, industry-first SA-CCR implementation, and velocity-factor risk assessment.