# Calculation Testing Strategy

## Overview

This document establishes comprehensive testing strategies for migrating calculation logic from your proven HTML calculators (FOR 2.0, KFR with SNI intelligence, industry-first SA-CCR K-TCD implementation, Risk Assessment with velocity factors) to the React/Next.js platform. Given the regulatory nature of MiFIDPRU calculations, **100% accuracy** is non-negotiable.

**Critical Principle**: Every calculation must produce identical results between HTML prototypes and React implementation, down to the penny.

**Your Calculator Assets**: 
- FOR Calculator 2.0 (dual approach, 6 categories, 24 subcategories, scenario planning)
- KFR Calculator 2.0 (all 9 K-factors, SNI classification intelligence)  
- K-TCD Calculator (industry-first web-based SA-CCR implementation)
- Risk Assessment Calculator (velocity factors, correlation modeling)

---

## Testing Architecture

### 1. Test Categories

#### Category A: Calculation Accuracy Tests
**Purpose**: Verify mathematical precision between HTML and React implementations  
**Tolerance**: £0.01 maximum deviation (penny-perfect accuracy)  
**Coverage**: 100% of calculation scenarios including your advanced features  

#### Category B: Data Flow Tests  
**Purpose**: Ensure data transformations preserve calculation integrity  
**Focus**: Input validation, data persistence, state management, multi-approach handling  

#### Category C: Integration Tests
**Purpose**: Verify calculator interactions and MCR aggregation  
**Scope**: Multi-calculator dependencies, real-time updates, scenario planning  

#### Category D: Regression Tests
**Purpose**: Prevent calculation logic degradation during development  
**Automation**: Continuous integration pipeline with regulatory validation  

### 2. Testing Methodology

#### Reference Data Generation from Your HTML Calculators
```bash
# Extract test cases from your existing HTML prototypes
node scripts/extract-html-test-cases.js

# Generate comprehensive test scenarios for your specific calculators
node scripts/generate-calculation-scenarios.js

# Validate reference calculations against regulatory examples
node scripts/validate-reference-data.js
```

#### Comparative Testing Framework
```typescript
interface CalculationTest {
  id: string;
  calculator: 'FOR' | 'KFR' | 'K_TCD' | 'K_NPR' | 'K_CON' | 'RISK_ASSESSMENT';
  scenario: string;
  input: CalculationInput;
  expectedResult: CalculationResult;
  tolerance: number;
  htmlReferenceFile: string;
  regulatoryBasis: string;
}

interface TestResult {
  testId: string;
  passed: boolean;
  reactResult: number;
  htmlResult: number;
  deviation: number;
  deviationPercentage: number;
  calculationBreakdown: Record<string, number>;
}
```

---

## FOR Calculator 2.0 Testing

### 1. Dual Approach Testing

#### Consolidated vs Granular Approach Validation
```typescript
describe('FOR Calculator 2.0 - Dual Approach Validation', () => {
  test('consolidated and granular approaches should yield identical results', () => {
    const consolidatedInput: FORInput = {
      approach: 'consolidated',
      totalExpenditure: 800000,
      financialYear: 2025
    };
    
    const granularInput: FORInput = {
      approach: 'granular',
      costCategories: {
        staff: { 
          name: 'Staff Costs',
          value: 500000,
          subcategories: {
            salaries: { name: 'Salaries & Wages', value: 400000 },
            bonuses: { name: 'Bonuses & Incentives', value: 80000 },
            benefits: { name: 'Benefits & Pensions', value: 15000 },
            training: { name: 'Training & Development', value: 5000 }
          }
        },
        professional: {
          name: 'Professional Fees',
          value: 120000,
          subcategories: {
            legal: { name: 'Legal Fees', value: 50000 },
            audit: { name: 'Audit & Accounting', value: 40000 },
            consultancy: { name: 'Consultancy Fees', value: 20000 },
            tax: { name: 'Tax & Advisory', value: 10000 }
          }
        },
        technology: {
          name: 'Technology/IT Costs',
          value: 80000,
          subcategories: {
            software: { name: 'Software Licences', value: 50000 },
            hardware: { name: 'Hardware & Equipment', value: 15000 },
            maintenance: { name: 'IT Maintenance', value: 10000 },
            telecoms: { name: 'Telecommunications', value: 5000 }
          }
        },
        occupancy: {
          name: 'Occupancy & Facilities',
          value: 60000,
          subcategories: {
            rent: { name: 'Rent & Rates', value: 48000 },
            utilities: { name: 'Utilities', value: 8000 },
            insurance: { name: 'Property Insurance', value: 2000 },
            maintenance: { name: 'Facilities Maintenance', value: 2000 }
          }
        },
        regulatory: {
          name: 'Regulatory & Compliance',
          value: 25000,
          subcategories: {
            fcaFees: { name: 'FCA Fees', value: 15000 },
            compliance: { name: 'Compliance Costs', value: 6000 },
            reporting: { name: 'Regulatory Reporting', value: 2000 },
            licensing: { name: 'Professional Licensing', value: 2000 }
          }
        },
        other: {
          name: 'Other Operating Costs',
          value: 15000,
          subcategories: {
            marketing: { name: 'Marketing & Business Development', value: 8000 },
            travel: { name: 'Travel & Entertainment', value: 4000 },
            office: { name: 'Office Supplies & Equipment', value: 2000 },
            miscellaneous: { name: 'Miscellaneous Expenses', value: 1000 }
          }
        }
      }
    };
    
    const consolidatedResult = FORCalculator.calculate(consolidatedInput);
    const granularResult = FORCalculator.calculate(granularInput);
    
    // Both approaches should yield £200,000 FOR (£800,000 ÷ 4)
    expect(consolidatedResult.forRequirement).toBeCloseTo(200000, 2);
    expect(granularResult.forRequirement).toBeCloseTo(200000, 2);
    expect(consolidatedResult.forRequirement).toBeCloseTo(granularResult.forRequirement, 2);
  });
});
```

#### Scenario Planning Validation
```typescript
describe('FOR Calculator 2.0 - Scenario Planning', () => {
  test('growth scenario should correctly model staff increases', () => {
    const baseInput: FORInput = {
      approach: 'granular',
      costCategories: {
        staff: { value: 500000, subcategories: { salaries: { value: 400000 } } }
        // ... other categories
      }
    };
    
    const growthScenario: ScenarioInput = {
      type: 'growth',
      staffIncrease: 0.25, // 25% staff increase
      infrastructureScaling: 0.15, // 15% tech scaling
      efficiencyGains: 0.05 // 5% efficiency improvement
    };
    
    const scenarioResult = FORScenarioCalculator.calculate(baseInput, growthScenario);
    
    // Staff costs should increase by 25%
    expect(scenarioResult.adjustedCosts.staff).toBeCloseTo(625000, 2);
    
    // FOR should reflect scenario adjustments
    expect(scenarioResult.adjustedFOR).toBeGreaterThan(scenarioResult.baseFOR);
    
    // Percentage change should be calculated correctly
    const expectedChange = ((scenarioResult.adjustedFOR - scenarioResult.baseFOR) / scenarioResult.baseFOR) * 100;
    expect(scenarioResult.percentageChange).toBeCloseTo(expectedChange, 2);
  });
});
```

### 2. FOR Adjustments Testing

#### One-off Items Exclusion (MiFIDPRU 4.5.3R)
```typescript
describe('FOR Calculator 2.0 - Adjustments Module', () => {
  test('should correctly handle one-off item exclusions per MiFIDPRU 4.5.3R', () => {
    const inputWithAdjustments: FORInput = {
      approach: 'consolidated',
      totalExpenditure: 1000000,
      adjustments: [
        {
          id: 1,
          description: 'Office relocation costs (one-off)',
          amount: 50000, // Subtract this one-off cost
          date: '2025-03-15'
        },
        {
          id: 2,
          description: 'Legal settlement (one-off)',
          amount: 25000, // Subtract this one-off cost
          date: '2025-02-10'
        }
      ]
    };
    
    const result = FORCalculator.calculate(inputWithAdjustments);
    
    // Adjusted expenditure should be £925,000 (£1M - £75K adjustments)
    expect(result.adjustedExpenditure).toBeCloseTo(925000, 2);
    
    // FOR should be £231,250 (£925,000 ÷ 4)
    expect(result.forRequirement).toBeCloseTo(231250, 2);
    
    // Adjustment total should be tracked
    expect(result.adjustmentTotal).toBeCloseTo(75000, 2);
    
    // Ensure regulatory compliance metadata
    expect(result.metadata.regulatoryBasis).toBe('MiFIDPRU 4.5.3R');
    expect(result.metadata.adjustmentsApplied).toBe(true);
  });
});
```

---

## KFR Calculator 2.0 Testing

### 1. SNI Classification Intelligence Testing

#### Automatic SNI/Non-SNI Determination
```typescript
describe('KFR Calculator 2.0 - SNI Classification', () => {
  test('should correctly identify SNI firms and set KFR to £0', () => {
    const sniFirmInput: KFRInput = {
      firmInfo: {
        firmName: 'Small Investment Advisers Ltd',
        fcaRef: '123456',
        totalAssets: 4000000, // Below £5M threshold
        balanceSheet: 3500000, // Below £5M threshold  
        annualIncome: 2800000, // Below £5M threshold
        businessType: 'advisory',
        holdsClientMoney: false,
        safeguardsAssets: false,
        dealsOwnAccount: false,
        executesOrders: false
      },
      kFactorData: {
        rtc: {
          k_aum: { active: true, value: 50000 }
        }
      }
    };
    
    const result = KFRCalculator.calculate(sniFirmInput);
    
    // SNI firms should have £0 KFR regardless of K-factor values
    expect(result.kfrRequirement).toBe(0);
    expect(result.sniClassification.isSNI).toBe(true);
    expect(result.sniClassification.reason).toContain('below SNI thresholds');
    
    // Should still show calculated K-factor values for transparency
    expect(result.calculatedKFactors.rtc.k_aum).toBeCloseTo(50000, 2);
  });
  
  test('should correctly identify Non-SNI firms and calculate KFR', () => {
    const nonSniFirmInput: KFRInput = {
      firmInfo: {
        firmName: 'Large Investment Bank Ltd',
        fcaRef: '789012',
        totalAssets: 50000000, // Above £5M threshold
        balanceSheet: 45000000, // Above £5M threshold
        annualIncome: 30000000, // Above £5M threshold
        businessType: 'discretionary',
        holdsClientMoney: true,
        safeguardsAssets: true,
        dealsOwnAccount: true,
        executesOrders: true
      },
      kFactorData: {
        rtc: {
          k_aum: { active: true, value: 100000 },
          k_cmh: { 
            active: true, 
            componentValues: {
              segregated: 50000,
              nonSegregated: 25000
            }
          }
        },
        rtm: {
          k_npr: { active: true, value: 75000 }
        },
        rtf: {
          k_tcd: { active: true, value: 120000 }
        }
      }
    };
    
    const result = KFRCalculator.calculate(nonSniFirmInput);
    
    // Non-SNI firms should have KFR = sum of all active K-factors
    const expectedKFR = 100000 + (50000 * 0.32 + 25000 * 0.32) + 75000 + 120000;
    expect(result.kfrRequirement).toBeCloseTo(expectedKFR, 2);
    expect(result.sniClassification.isSNI).toBe(false);
  });
});
```

### 2. Component-Based K-Factor Testing

#### K-CMH Component Calculation
```typescript
describe('KFR Calculator 2.0 - Component Calculations', () => {
  test('K-CMH should correctly apply different coefficients to components', () => {
    const kcmhInput = {
      k_cmh: {
        active: true,
        componentValues: {
          segregated: 1000000,      // 0.32% coefficient
          nonSegregated: 500000     // 0.32% coefficient  
        }
      }
    };
    
    const result = KFactorCalculator.calculateKCMH(kcmhInput.k_cmh);
    
    // Segregated: £1M × 0.0032 = £3,200
    expect(result.segregatedComponent).toBeCloseTo(3200, 2);
    
    // Non-segregated: £500K × 0.0032 = £1,600  
    expect(result.nonSegregatedComponent).toBeCloseTo(1600, 2);
    
    // Total K-CMH: £3,200 + £1,600 = £4,800
    expect(result.totalKCMH).toBeCloseTo(4800, 2);
    
    // Coefficient transparency
    expect(result.coefficients.segregated).toBe(0.0032);
    expect(result.coefficients.nonSegregated).toBe(0.0032);
  });
  
  test('K-COH should handle cash and derivatives components', () => {
    const kcohInput = {
      k_coh: {
        active: true,
        componentValues: {
          cash: 2000000,           // 0.16% coefficient
          derivatives: 800000     // 0.16% coefficient
        }
      }
    };
    
    const result = KFactorCalculator.calculateKCOH(kcohInput.k_coh);
    
    // Cash: £2M × 0.0016 = £3,200
    expect(result.cashComponent).toBeCloseTo(3200, 2);
    
    // Derivatives: £800K × 0.0016 = £1,280
    expect(result.derivativesComponent).toBeCloseTo(1280, 2);
    
    // Total K-COH: £3,200 + £1,280 = £4,480
    expect(result.totalKCOH).toBeCloseTo(4480, 2);
  });
});
```

---

## K-TCD SA-CCR Testing (Industry First Implementation)

### 1. SA-CCR Methodology Validation

#### Replacement Cost (RC) Calculation
```typescript
describe('K-TCD Calculator - SA-CCR Implementation', () => {
  test('should correctly calculate Replacement Cost with VM agreement', () => {
    const nettingSetInput: NettingSetInput = {
      id: 'NS001',
      counterparty: 'Major Bank Ltd',
      counterpartyType: 'financial',
      riskWeight: 0.02, // 2% for bank
      marginType: 'vm', // Variation margin only
      collateralHeld: 50000,
      collateralPosted: 30000,
      threshold: 0,
      transactions: [
        {
          assetClass: 'ir',
          productType: 'swap',
          notional: 10000000,
          marketValue: 150000, // Positive MTM
          maturity: 3,
          position: 'long'
        },
        {
          assetClass: 'ir', 
          productType: 'swap',
          notional: 5000000,
          marketValue: -80000, // Negative MTM
          maturity: 2,
          position: 'short'
        }
      ]
    };
    
    const result = KTCDCalculator.calculateReplacementCost(nettingSetInput);
    
    // V = 150,000 - 80,000 = 70,000
    const netMarketValue = 70000;
    
    // C = 50,000 - 30,000 = 20,000  
    const netCollateral = 20000;
    
    // RC = max(V - C, 0) = max(70,000 - 20,000, 0) = 50,000
    expect(result.replacementCost).toBeCloseTo(50000, 2);
    expect(result.netMarketValue).toBeCloseTo(70000, 2);
    expect(result.netCollateral).toBeCloseTo(20000, 2);
  });
  
  test('should correctly calculate PFE with asset class aggregation', () => {
    const multiAssetInput: NettingSetInput = {
      // ... netting set details
      transactions: [
        // Interest Rate trades
        {
          assetClass: 'ir',
          notional: 10000000,
          maturity: 3,
          // ... other details
        },
        {
          assetClass: 'ir',
          notional: 5000000, 
          maturity: 1,
          // ... other details
        },
        // FX trades
        {
          assetClass: 'fx',
          notional: 2000000,
          maturity: 0.5,
          // ... other details
        }
      ]
    };
    
    const result = KTCDCalculator.calculatePFE(multiAssetInput);
    
    // IR effective notional with 50% correlation
    // Effective notional = sqrt(sum of squared notionals with correlation)
    const irEffectiveNotional = Math.sqrt(
      Math.pow(10000000, 2) + 
      Math.pow(5000000, 2) + 
      2 * 0.5 * 10000000 * 5000000
    );
    
    // FX effective notional (no correlation within same class)
    const fxEffectiveNotional = 2000000;
    
    // Apply supervisory factors: IR = 0.5%, FX = 4%
    const irPFE = irEffectiveNotional * 0.005;
    const fxPFE = fxEffectiveNotional * 0.04;
    
    expect(result.assetClassBreakdown.ir.effectiveNotional).toBeCloseTo(irEffectiveNotional, 0);
    expect(result.assetClassBreakdown.fx.effectiveNotional).toBeCloseTo(fxEffectiveNotional, 0);
    expect(result.assetClassBreakdown.ir.pfe).toBeCloseTo(irPFE, 2);
    expect(result.assetClassBreakdown.fx.pfe).toBeCloseTo(fxPFE, 2);
    expect(result.totalPFE).toBeCloseTo(irPFE + fxPFE, 2);
  });
});
```

### 2. Multi-Asset Class Testing

#### Complete SA-CCR Calculation Chain
```typescript
describe('K-TCD Calculator - Complete SA-CCR Chain', () => {
  test('should produce correct EAD and K-TCD for complex portfolio', () => {
    const complexPortfolio: KTCDInput = {
      nettingSets: [
        {
          id: 'NS001',
          counterparty: 'Bank A',
          riskWeight: 0.02,
          marginType: 'vmim', // Both VM and IM
          transactions: [
            // Large IR portfolio
            ...generateIRSwapPortfolio(50000000, 10), // £50M notional, 10 trades
            // FX portfolio  
            ...generateFXForwardPortfolio(20000000, 5), // £20M notional, 5 trades
            // Equity derivatives
            ...generateEquityOptionPortfolio(10000000, 3) // £10M notional, 3 trades
          ]
        },
        {
          id: 'NS002',
          counterparty: 'Bank B', 
          riskWeight: 0.0075, // Lower risk weight
          marginType: 'vm',
          transactions: [
            // Different asset mix
            ...generateCreditDefaultSwaps(30000000, 8)
          ]
        }
      ]
    };
    
    const result = KTCDCalculator.calculate(complexPortfolio);
    
    // Validate each netting set calculation
    result.nettingSetResults.forEach(nsResult => {
      // EAD = 1.4 × (RC + PFE)
      const expectedEAD = 1.4 * (nsResult.replacementCost + nsResult.potentialFutureExposure);
      expect(nsResult.exposureAtDefault).toBeCloseTo(expectedEAD, 2);
      
      // RWA = EAD × Risk Weight
      const expectedRWA = nsResult.exposureAtDefault * nsResult.riskWeight;
      expect(nsResult.riskWeightedAssets).toBeCloseTo(expectedRWA, 2);
    });
    
    // K-TCD = Sum of all RWA + CVA charge
    const totalRWA = result.nettingSetResults.reduce(
      (sum, ns) => sum + ns.riskWeightedAssets, 
      0
    );
    const cvaCharge = totalRWA * 0.015; // 1.5% CVA multiplier
    const expectedKTCD = totalRWA + cvaCharge;
    
    expect(result.totalKTCD).toBeCloseTo(expectedKTCD, 2);
    expect(result.cvaCharge).toBeCloseTo(cvaCharge, 2);
    
    // Ensure industry-first web implementation features
    expect(result.calculationMetadata.methodology).toBe('SA-CCR');
    expect(result.calculationMetadata.implementationType).toBe('web-based');
    expect(result.calculationMetadata.industryFirst).toBe(true);
  });
});
```

---

## Risk Assessment Calculator Testing

### 1. Velocity Factor Testing

#### Speed of Risk Crystallization
```typescript
describe('Risk Assessment Calculator - Velocity Factors', () => {
  test('should correctly model risk velocity in capital allocation', () => {
    const riskWithVelocity: RiskInput = {
      riskId: 'RISK_001',
      category: 'operational',
      description: 'Cyber attack on trading systems',
      impact: 9, // High impact
      likelihood: 6, // Medium likelihood
      controlEffectiveness: 7, // Good controls
      
      // Your industry-first velocity factor
      velocityFactor: {
        crystallizationSpeed: 'immediate', // <24 hours
        detectionLag: 'short', // <1 week
        responseTime: 'fast', // <1 day
        recoveryDuration: 'medium' // 1-4 weeks
      }
    };
    
    const result = RiskCalculator.calculateWithVelocity(riskWithVelocity);
    
    // Base gross risk = 9 × 6 = 54
    expect(result.grossRisk).toBe(54);
    
    // Controls reduce to net risk = 54 × (1 - 0.7) = 16.2
    expect(result.netRisk).toBeCloseTo(16.2, 1);
    
    // Velocity adjustment should increase capital requirement
    // Fast crystallization requires higher capital buffer
    expect(result.velocityAdjustedRisk).toBeGreaterThan(result.netRisk);
    
    // Velocity multiplier should be >1 for immediate crystallization
    expect(result.velocityMultiplier).toBeGreaterThan(1.0);
    expect(result.velocityMultiplier).toBeLessThan(2.0); // Reasonable bounds
  });
});
```

### 2. Correlation Modeling Testing

#### Risk Interdependency Recognition
```typescript
describe('Risk Assessment Calculator - Correlation Modeling', () => {
  test('should correctly model risk correlations in portfolio effect', () => {
    const correlatedRisks: RiskPortfolio = {
      risks: [
        {
          id: 'RISK_001',
          category: 'operational',
          netRisk: 20,
          velocityAdjustedRisk: 25
        },
        {
          id: 'RISK_002', 
          category: 'operational', // Same category = higher correlation
          netRisk: 15,
          velocityAdjustedRisk: 18
        },
        {
          id: 'RISK_003',
          category: 'liquidity', // Different category = lower correlation
          netRisk: 30,
          velocityAdjustedRisk: 35
        }
      ],
      correlationMatrix: {
        'RISK_001-RISK_002': 0.7, // High correlation (same category)
        'RISK_001-RISK_003': 0.3, // Lower correlation (different categories)
        'RISK_002-RISK_003': 0.2  // Lower correlation
      }
    };
    
    const result = RiskCalculator.calculatePortfolioCapital(correlatedRisks);
    
    // Individual sum would be 25 + 18 + 35 = 78
    const individualSum = 78;
    
    // Portfolio effect should reduce total due to diversification
    expect(result.portfolioCapital).toBeLessThan(individualSum);
    
    // Diversification benefit should be calculated and reported
    const diversificationBenefit = individualSum - result.portfolioCapital;
    expect(result.diversificationBenefit).toBeCloseTo(diversificationBenefit, 2);
    expect(result.diversificationBenefit).toBeGreaterThan(0);
    
    // Correlation effects should be documented
    expect(result.correlationEffects).toBeDefined();
    expect(result.correlationEffects.highestCorrelation).toBe(0.7);
  });
});
```

---

## Cross-Validation Testing Framework

### 1. HTML Prototype Reference Extraction

#### Automated Test Case Generation from Your Calculators
```javascript
// scripts/extract-html-reference-data.js
const fs = require('fs');
const jsdom = require('jsdom');
const { JSDOM } = jsdom;

async function extractFORReferenceData() {
  // Load your FOR Calculator 2.0 HTML
  const htmlContent = fs.readFileSync('./legacy/FORCalc_.html', 'utf8');
  const dom = new JSDOM(htmlContent, { runScripts: 'dangerously' });
  const window = dom.window;
  
  // Test scenarios for your specific FOR calculator features
  const forTestScenarios = [
    {
      id: 'FOR_GRANULAR_6CAT_24SUBCAT',
      description: 'Full granular calculation with all 6 categories and 24 subcategories',
      inputs: {
        approach: 'granular',
        // Staff category (4 subcategories)
        staffSalaries: 400000,
        staffBonuses: 80000,
        staffBenefits: 15000,
        staffTraining: 5000,
        // Professional category (4 subcategories)  
        professionalLegal: 50000,
        professionalAudit: 40000,
        professionalConsultancy: 20000,
        professionalTax: 10000,
        // Technology category (4 subcategories)
        technologySoftware: 50000,
        technologyHardware: 15000,
        technologyMaintenance: 10000,
        technologyTelecoms: 5000,
        // Occupancy category (4 subcategories)
        occupancyRent: 48000,
        occupancyUtilities: 8000,
        occupancyInsurance: 2000,
        occupancyMaintenance: 2000,
        // Regulatory category (4 subcategories)
        regulatoryFCA: 15000,
        regulatoryCompliance: 6000,
        regulatoryReporting: 2000,
        regulatoryLicensing: 2000,
        // Other category (4 subcategories)
        otherMarketing: 8000,
        otherTravel: 4000,
        otherOffice: 2000,
        otherMiscellaneous: 1000
      }
    },
    {
      id: 'FOR_SCENARIO_PLANNING',
      description: 'Growth scenario with 25% staff increase',
      inputs: {
        // Base calculation + scenario parameters
        baseStaffCosts: 500000,
        growthScenario: {
          staffIncrease: 0.25,
          infrastructureScaling: 0.15,
          efficiencyGains: 0.05
        }
      }
    }
  ];
  
  const extractedResults = [];
  
  for (const scenario of forTestScenarios) {
    // Execute scenario in HTML calculator
    Object.entries(scenario.inputs).forEach(([field, value]) => {
      const element = window.document.getElementById(field);
      if (element) {
        element.value = value;
        element.dispatchEvent(new window.Event('input'));
      }
    });
    
    // Trigger your calculator's calculation function
    if (window.calculateFOR) {
      window.calculateFOR();
    }
    
    // Extract results
    const forValue = parseFloat(
      window.document.getElementById('forValue')?.textContent?.replace(/[£,]/g, '') || '0'
    );
    const totalCosts = parseFloat(
      window.document.getElementById('totalCosts')?.textContent?.replace(/[£,]/g, '') || '0'
    );
    
    extractedResults.push({
      id: scenario.id,
      description: scenario.description,
      input: scenario.inputs,
      htmlResult: {
        forValue,
        totalCosts,
        timestamp: new Date().toISOString(),
        calculatorVersion: '2.0'
      }
    });
  }
  
  // Save reference data
  fs.writeFileSync(
    './tests/reference-data/for-2.0-reference.json', 
    JSON.stringify(extractedResults, null, 2)
  );
  
  console.log(`Extracted ${extractedResults.length} FOR 2.0 test cases`);
}

// Similar extraction for other calculators
async function extractKFRReferenceData() {
  // Extract from your KFR Calculator 2.0 with SNI intelligence
}

async function extractKTCDReferenceData() {  
  // Extract from your industry-first SA-CCR implementation
}

// Run all extractions
Promise.all([
  extractFORReferenceData(),
  extractKFRReferenceData(), 
  extractKTCDReferenceData()
]).then(() => {
  console.log('All reference data extraction complete');
});
```

### 2. React vs HTML Validation Suite

#### Comprehensive Cross-Validation Testing
```typescript
// tests/cross-validation/for-calculator.test.ts
import { FORCalculator } from '@icara/calculators';
import forReferenceData from '../reference-data/for-2.0-reference.json';

describe('FOR Calculator 2.0 - HTML vs React Cross-Validation', () => {
  forReferenceData.forEach(referenceCase => {
    test(`${referenceCase.id}: ${referenceCase.description}`, () => {
      // Transform HTML input format to React format
      const reactInput = transformFORInputToReact(referenceCase.input);
      
      // Calculate using React implementation
      const reactResult = FORCalculator.calculate(reactInput);
      
      // Extract HTML results
      const htmlResult = referenceCase.htmlResult;
      
      // Compare core calculations (penny-perfect accuracy)
      const deviation = Math.abs(reactResult.forRequirement - htmlResult.forValue);
      const deviationPercentage = (deviation / htmlResult.forValue) * 100;
      
      // Assert within tolerance
      expect(deviation).toBeLessThanOrEqual(0.01);
      expect(deviationPercentage).toBeLessThanOrEqual(0.001); // 0.001% tolerance
      
      // Validate total costs match
      expect(reactResult.annualExpenditure).toBeCloseTo(htmlResult.totalCosts, 2);
      
      // Log detailed comparison for audit trail
      console.log(`✅ Cross-validation ${referenceCase.id}:`, {
        html: htmlResult.forValue,
        react: reactResult.forRequirement,
        deviation,
        deviationPercentage: `${deviationPercentage.toFixed(6)}%`,
        status: deviation <= 0.01 ? 'PASS' : 'FAIL'
      });
      
      // Ensure calculation metadata is preserved
      expect(reactResult.metadata.calculatorVersion).toBeDefined();
      expect(reactResult.metadata.regulatoryBasis).toBe('MiFIDPRU 4.5');
    });
  });
});

function transformFORInputToReact(htmlInput: any): FORInput {
  if (htmlInput.approach === 'granular') {
    return {
      approach: 'granular',
      costCategories: {
        staff: {
          name: 'Staff Costs',
          value: (htmlInput.staffSalaries || 0) + (htmlInput.staffBonuses || 0) + 
                 (htmlInput.staffBenefits || 0) + (htmlInput.staffTraining || 0),
          subcategories: {
            salaries: { name: 'Salaries & Wages', value: htmlInput.staffSalaries || 0 },
            bonuses: { name: 'Bonuses & Incentives', value: htmlInput.staffBonuses || 0 },
            benefits: { name: 'Benefits & Pensions', value: htmlInput.staffBenefits || 0 },
            training: { name: 'Training & Development', value: htmlInput.staffTraining || 0 }
          }
        },
        // ... transform other categories with all subcategories
      }
    };
  } else {
    return {
      approach: 'consolidated',
      totalExpenditure: htmlInput.totalExpenditure,
      financialYear: htmlInput.financialYear
    };
  }
}
```

---

## Automated Testing Pipeline

### 1. Continuous Integration for Calculator Migration

#### GitHub Actions Workflow
```yaml
# .github/workflows/calculator-migration-tests.yml
name: Calculator Migration Accuracy Tests

on:
  push:
    branches: [ main, develop ]
    paths: 
      - 'packages/calculators/**'
      - 'apps/web/src/app/calculator/**'
  pull_request:
    branches: [ main ]

jobs:
  calculation-accuracy:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: icara_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'
        cache: 'pnpm'
    
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
    
    - name: Generate Prisma client
      run: pnpm db:generate
    
    - name: Run cross-validation tests
      run: pnpm test:cross-validation
      env:
        DATABASE_URL: postgresql://postgres:test_password@localhost:5432/icara_test
    
    - name: Run regulatory compliance tests
      run: pnpm test:regulatory
    
    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: calculator-migration-results
        path: |
          test-results/
          validation-results/
          
    - name: Calculator Accuracy Report
      run: |
        echo "## Calculator Migration Test Results" >> $GITHUB_STEP_SUMMARY
        echo "### Cross-Validation Results" >> $GITHUB_STEP_SUMMARY
        cat validation-results/cross-validation-summary.md >> $GITHUB_STEP_SUMMARY
```

### 2. Performance Benchmarking

#### Calculator Performance Standards
```typescript
describe('Calculator Performance Requirements', () => {
  test('FOR Calculator should complete within 50ms', async () => {
    const startTime = performance.now();
    
    const result = FORCalculator.calculate(standardFORInput);
    
    const endTime = performance.now();
    const duration = endTime - startTime;
    
    expect(duration).toBeLessThan(50); // Your granular calculator is complex
    expect(result).toBeDefined();
    expect(result.forRequirement).toBeGreaterThan(0);
  });
  
  test('K-TCD SA-CCR should handle 100 transactions within 200ms', async () => {
    const largePortfolio = generateLargeKTCDPortfolio(100);
    
    const startTime = performance.now();
    const result = KTCDCalculator.calculate(largePortfolio);
    const endTime = performance.now();
    
    expect(endTime - startTime).toBeLessThan(200);
    expect(result.nettingSetResults).toHaveLength(10); // Assume 10 netting sets
    expect(result.totalKTCD).toBeGreaterThan(0);
  });
  
  test('Risk Assessment with velocity factors should complete within 100ms', async () => {
    const complexRiskPortfolio = generateComplexRiskPortfolio(50);
    
    const startTime = performance.now();
    const result = RiskCalculator.calculatePortfolioCapital(complexRiskPortfolio);
    const endTime = performance.now();
    
    expect(endTime - startTime).toBeLessThan(100);
    expect(result.portfolioCapital).toBeDefined();
    expect(result.diversificationBenefit).toBeGreaterThan(0);
  });
});
```

---

## Regulatory Validation Testing

### 1. MiFIDPRU Compliance Testing

#### Regulatory Methodology Validation
```typescript
describe('Regulatory Compliance - MiFIDPRU Requirements', () => {
  test('FOR calculation should comply with MiFIDPRU 4.5', () => {
    // Test against official FCA examples
    const fcaExampleInput = getFCAExample_FOR_BasicCalculation();
    const result = FORCalculator.calculate(fcaExampleInput);
    
    // Validate against published FCA calculation
    const fcaExpectedResult = getFCAExpectedResult_FOR_Basic();
    expect(result.forRequirement).toBeCloseTo(fcaExpectedResult, 2);
    
    // Ensure methodology documentation
    expect(result.metadata.regulatoryReference).toContain('MiFIDPRU 4.5');
    expect(result.metadata.calculationMethod).toBe('quarterly_division');
  });
  
  test('K-TCD SA-CCR should comply with CRR Article 274-280', () => {
    // Test against regulatory examples
    const crrExamplePortfolio = getCRRExample_SACCR_BasicPortfolio();
    const result = KTCDCalculator.calculate(crrExamplePortfolio);
    
    // Validate SA-CCR implementation
    expect(result.calculationMetadata.methodology).toBe('SA-CCR');
    expect(result.calculationMetadata.regulatoryBasis).toContain('CRR Article 274');
    
    // Ensure alpha factor is correctly applied
    expect(result.alphaFactor).toBe(1.4);
    
    // Validate CVA charge calculation
    const expectedCVA = result.totalRWA * 0.015;
    expect(result.cvaCharge).toBeCloseTo(expectedCVA, 2);
  });
});
```

### 2. Audit Trail Validation

#### Complete Calculation Traceability
```typescript
describe('Audit Trail Requirements', () => {
  test('all calculations should have complete audit trail', () => {
    const calculation = performTrackedCalculation(testInput);
    
    // Verify audit metadata
    expect(calculation.metadata).toHaveProperty('calculationId');
    expect(calculation.metadata).toHaveProperty('timestamp');
    expect(calculation.metadata).toHaveProperty('userId');
    expect(calculation.metadata).toHaveProperty('inputHash');
    expect(calculation.metadata).toHaveProperty('calculatorVersion');
    expect(calculation.metadata).toHaveProperty('regulatoryVersion');
    
    // Verify calculation is reproducible
    const reproduced = reproduceCalculationFromAudit(calculation.metadata.calculationId);
    expect(reproduced.result).toEqual(calculation.result);
  });
  
  test('calculation steps should be traceable', () => {
    const detailedResult = FORCalculator.calculateWithSteps(testInput);
    
    // Each step should be documented
    expect(detailedResult.calculationSteps).toBeDefined();
    expect(detailedResult.calculationSteps.length).toBeGreaterThan(0);
    
    // Step-by-step validation
    detailedResult.calculationSteps.forEach(step => {
      expect(step).toHaveProperty('stepNumber');
      expect(step).toHaveProperty('description');
      expect(step).toHaveProperty('inputValue');
      expect(step).toHaveProperty('outputValue');
      expect(step).toHaveProperty('formula');
    });
  });
});
```

This comprehensive testing strategy ensures your sophisticated HTML calculators (FOR 2.0, KFR with SNI intelligence, industry-first SA-CCR K-TCD, Risk Assessment with velocity factors) are migrated with absolute precision while maintaining all advanced features and regulatory compliance.